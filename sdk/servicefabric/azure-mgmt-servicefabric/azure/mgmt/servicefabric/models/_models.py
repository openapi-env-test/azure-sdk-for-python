# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.serialization import Model
from msrest.exceptions import HttpOperationError


class ApplicationDeltaHealthPolicy(Model):
    """Defines a delta health policy used to evaluate the health of an application
    or one of its child entities when upgrading the cluster.
    .

    :param default_service_type_delta_health_policy: The delta health policy
     used by default to evaluate the health of a service type when upgrading
     the cluster.
    :type default_service_type_delta_health_policy:
     ~azure.mgmt.servicefabric.models.ServiceTypeDeltaHealthPolicy
    :param service_type_delta_health_policies: The map with service type delta
     health policy per service type name. The map is empty by default.
    :type service_type_delta_health_policies: dict[str,
     ~azure.mgmt.servicefabric.models.ServiceTypeDeltaHealthPolicy]
    """

    _attribute_map = {
        'default_service_type_delta_health_policy': {'key': 'defaultServiceTypeDeltaHealthPolicy', 'type': 'ServiceTypeDeltaHealthPolicy'},
        'service_type_delta_health_policies': {'key': 'serviceTypeDeltaHealthPolicies', 'type': '{ServiceTypeDeltaHealthPolicy}'},
    }

    def __init__(self, **kwargs):
        super(ApplicationDeltaHealthPolicy, self).__init__(**kwargs)
        self.default_service_type_delta_health_policy = kwargs.get('default_service_type_delta_health_policy', None)
        self.service_type_delta_health_policies = kwargs.get('service_type_delta_health_policies', None)


class ApplicationHealthPolicy(Model):
    """Defines a health policy used to evaluate the health of an application or
    one of its children entities.
    .

    :param default_service_type_health_policy: The health policy used by
     default to evaluate the health of a service type.
    :type default_service_type_health_policy:
     ~azure.mgmt.servicefabric.models.ServiceTypeHealthPolicy
    :param service_type_health_policies: The map with service type health
     policy per service type name. The map is empty by default.
    :type service_type_health_policies: dict[str,
     ~azure.mgmt.servicefabric.models.ServiceTypeHealthPolicy]
    """

    _attribute_map = {
        'default_service_type_health_policy': {'key': 'defaultServiceTypeHealthPolicy', 'type': 'ServiceTypeHealthPolicy'},
        'service_type_health_policies': {'key': 'serviceTypeHealthPolicies', 'type': '{ServiceTypeHealthPolicy}'},
    }

    def __init__(self, **kwargs):
        super(ApplicationHealthPolicy, self).__init__(**kwargs)
        self.default_service_type_health_policy = kwargs.get('default_service_type_health_policy', None)
        self.service_type_health_policies = kwargs.get('service_type_health_policies', None)


class AvailableOperationDisplay(Model):
    """Operation supported by the Service Fabric resource provider.

    :param provider: The name of the provider.
    :type provider: str
    :param resource: The resource on which the operation is performed
    :type resource: str
    :param operation: The operation that can be performed.
    :type operation: str
    :param description: Operation description
    :type description: str
    """

    _attribute_map = {
        'provider': {'key': 'provider', 'type': 'str'},
        'resource': {'key': 'resource', 'type': 'str'},
        'operation': {'key': 'operation', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(AvailableOperationDisplay, self).__init__(**kwargs)
        self.provider = kwargs.get('provider', None)
        self.resource = kwargs.get('resource', None)
        self.operation = kwargs.get('operation', None)
        self.description = kwargs.get('description', None)


class CloudError(Model):
    """CloudError.
    """

    _attribute_map = {
    }


class ClusterHealthPolicy(Model):
    """Defines a health policy used to evaluate the health of the cluster or of a
    cluster node.
    .

    :param max_percent_unhealthy_nodes: The maximum allowed percentage of
     unhealthy nodes before reporting an error. For example, to allow 10% of
     nodes to be unhealthy, this value would be 10.
     The percentage represents the maximum tolerated percentage of nodes that
     can be unhealthy before the cluster is considered in error.
     If the percentage is respected but there is at least one unhealthy node,
     the health is evaluated as Warning.
     The percentage is calculated by dividing the number of unhealthy nodes
     over the total number of nodes in the cluster.
     The computation rounds up to tolerate one failure on small numbers of
     nodes. Default percentage is zero.
     In large clusters, some nodes will always be down or out for repairs, so
     this percentage should be configured to tolerate that.
     . Default value: 0 .
    :type max_percent_unhealthy_nodes: int
    :param max_percent_unhealthy_applications: The maximum allowed percentage
     of unhealthy applications before reporting an error. For example, to allow
     10% of applications to be unhealthy, this value would be 10.
     The percentage represents the maximum tolerated percentage of applications
     that can be unhealthy before the cluster is considered in error.
     If the percentage is respected but there is at least one unhealthy
     application, the health is evaluated as Warning.
     This is calculated by dividing the number of unhealthy applications over
     the total number of application instances in the cluster, excluding
     applications of application types that are included in the
     ApplicationTypeHealthPolicyMap.
     The computation rounds up to tolerate one failure on small numbers of
     applications. Default percentage is zero.
     . Default value: 0 .
    :type max_percent_unhealthy_applications: int
    :param application_health_policies: Defines the application health policy
     map used to evaluate the health of an application or one of its children
     entities.
    :type application_health_policies: dict[str,
     ~azure.mgmt.servicefabric.models.ApplicationHealthPolicy]
    """

    _validation = {
        'max_percent_unhealthy_nodes': {'maximum': 100, 'minimum': 0},
        'max_percent_unhealthy_applications': {'maximum': 100, 'minimum': 0},
    }

    _attribute_map = {
        'max_percent_unhealthy_nodes': {'key': 'maxPercentUnhealthyNodes', 'type': 'int'},
        'max_percent_unhealthy_applications': {'key': 'maxPercentUnhealthyApplications', 'type': 'int'},
        'application_health_policies': {'key': 'applicationHealthPolicies', 'type': '{ApplicationHealthPolicy}'},
    }

    def __init__(self, **kwargs):
        super(ClusterHealthPolicy, self).__init__(**kwargs)
        self.max_percent_unhealthy_nodes = kwargs.get('max_percent_unhealthy_nodes', 0)
        self.max_percent_unhealthy_applications = kwargs.get('max_percent_unhealthy_applications', 0)
        self.application_health_policies = kwargs.get('application_health_policies', None)


class ClusterUpgradeDeltaHealthPolicy(Model):
    """Describes the delta health policies for the cluster upgrade.

    All required parameters must be populated in order to send to Azure.

    :param max_percent_delta_unhealthy_nodes: Required. The maximum allowed
     percentage of nodes health degradation allowed during cluster upgrades.
     The delta is measured between the state of the nodes at the beginning of
     upgrade and the state of the nodes at the time of the health evaluation.
     The check is performed after every upgrade domain upgrade completion to
     make sure the global state of the cluster is within tolerated limits.
    :type max_percent_delta_unhealthy_nodes: int
    :param max_percent_upgrade_domain_delta_unhealthy_nodes: Required. The
     maximum allowed percentage of upgrade domain nodes health degradation
     allowed during cluster upgrades.
     The delta is measured between the state of the upgrade domain nodes at the
     beginning of upgrade and the state of the upgrade domain nodes at the time
     of the health evaluation.
     The check is performed after every upgrade domain upgrade completion for
     all completed upgrade domains to make sure the state of the upgrade
     domains is within tolerated limits.
    :type max_percent_upgrade_domain_delta_unhealthy_nodes: int
    :param max_percent_delta_unhealthy_applications: Required. The maximum
     allowed percentage of applications health degradation allowed during
     cluster upgrades.
     The delta is measured between the state of the applications at the
     beginning of upgrade and the state of the applications at the time of the
     health evaluation.
     The check is performed after every upgrade domain upgrade completion to
     make sure the global state of the cluster is within tolerated limits.
     System services are not included in this.
    :type max_percent_delta_unhealthy_applications: int
    :param application_delta_health_policies: Defines the application delta
     health policy map used to evaluate the health of an application or one of
     its child entities when upgrading the cluster.
    :type application_delta_health_policies: dict[str,
     ~azure.mgmt.servicefabric.models.ApplicationDeltaHealthPolicy]
    """

    _validation = {
        'max_percent_delta_unhealthy_nodes': {'required': True, 'maximum': 100, 'minimum': 0},
        'max_percent_upgrade_domain_delta_unhealthy_nodes': {'required': True, 'maximum': 100, 'minimum': 0},
        'max_percent_delta_unhealthy_applications': {'required': True, 'maximum': 100, 'minimum': 0},
    }

    _attribute_map = {
        'max_percent_delta_unhealthy_nodes': {'key': 'maxPercentDeltaUnhealthyNodes', 'type': 'int'},
        'max_percent_upgrade_domain_delta_unhealthy_nodes': {'key': 'maxPercentUpgradeDomainDeltaUnhealthyNodes', 'type': 'int'},
        'max_percent_delta_unhealthy_applications': {'key': 'maxPercentDeltaUnhealthyApplications', 'type': 'int'},
        'application_delta_health_policies': {'key': 'applicationDeltaHealthPolicies', 'type': '{ApplicationDeltaHealthPolicy}'},
    }

    def __init__(self, **kwargs):
        super(ClusterUpgradeDeltaHealthPolicy, self).__init__(**kwargs)
        self.max_percent_delta_unhealthy_nodes = kwargs.get('max_percent_delta_unhealthy_nodes', None)
        self.max_percent_upgrade_domain_delta_unhealthy_nodes = kwargs.get('max_percent_upgrade_domain_delta_unhealthy_nodes', None)
        self.max_percent_delta_unhealthy_applications = kwargs.get('max_percent_delta_unhealthy_applications', None)
        self.application_delta_health_policies = kwargs.get('application_delta_health_policies', None)


class ClusterUpgradePolicy(Model):
    """Describes the policy used when upgrading the cluster.

    All required parameters must be populated in order to send to Azure.

    :param force_restart: If true, then processes are forcefully restarted
     during upgrade even when the code version has not changed (the upgrade
     only changes configuration or data).
    :type force_restart: bool
    :param upgrade_replica_set_check_timeout: Required. The maximum amount of
     time to block processing of an upgrade domain and prevent loss of
     availability when there are unexpected issues. When this timeout expires,
     processing of the upgrade domain will proceed regardless of availability
     loss issues. The timeout is reset at the start of each upgrade domain. The
     timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
    :type upgrade_replica_set_check_timeout: str
    :param health_check_wait_duration: Required. The length of time to wait
     after completing an upgrade domain before performing health checks. The
     duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
    :type health_check_wait_duration: str
    :param health_check_stable_duration: Required. The amount of time that the
     application or cluster must remain healthy before the upgrade proceeds to
     the next upgrade domain. The duration can be in either hh:mm:ss or in
     d.hh:mm:ss.ms format.
    :type health_check_stable_duration: str
    :param health_check_retry_timeout: Required. The amount of time to retry
     health evaluation when the application or cluster is unhealthy before the
     upgrade rolls back. The timeout can be in either hh:mm:ss or in
     d.hh:mm:ss.ms format.
    :type health_check_retry_timeout: str
    :param upgrade_timeout: Required. The amount of time the overall upgrade
     has to complete before the upgrade rolls back. The timeout can be in
     either hh:mm:ss or in d.hh:mm:ss.ms format.
    :type upgrade_timeout: str
    :param upgrade_domain_timeout: Required. The amount of time each upgrade
     domain has to complete before the upgrade rolls back. The timeout can be
     in either hh:mm:ss or in d.hh:mm:ss.ms format.
    :type upgrade_domain_timeout: str
    :param health_policy: Required. The cluster health policy used when
     upgrading the cluster.
    :type health_policy: ~azure.mgmt.servicefabric.models.ClusterHealthPolicy
    :param delta_health_policy: The cluster delta health policy used when
     upgrading the cluster.
    :type delta_health_policy:
     ~azure.mgmt.servicefabric.models.ClusterUpgradeDeltaHealthPolicy
    """

    _validation = {
        'upgrade_replica_set_check_timeout': {'required': True},
        'health_check_wait_duration': {'required': True},
        'health_check_stable_duration': {'required': True},
        'health_check_retry_timeout': {'required': True},
        'upgrade_timeout': {'required': True},
        'upgrade_domain_timeout': {'required': True},
        'health_policy': {'required': True},
    }

    _attribute_map = {
        'force_restart': {'key': 'forceRestart', 'type': 'bool'},
        'upgrade_replica_set_check_timeout': {'key': 'upgradeReplicaSetCheckTimeout', 'type': 'str'},
        'health_check_wait_duration': {'key': 'healthCheckWaitDuration', 'type': 'str'},
        'health_check_stable_duration': {'key': 'healthCheckStableDuration', 'type': 'str'},
        'health_check_retry_timeout': {'key': 'healthCheckRetryTimeout', 'type': 'str'},
        'upgrade_timeout': {'key': 'upgradeTimeout', 'type': 'str'},
        'upgrade_domain_timeout': {'key': 'upgradeDomainTimeout', 'type': 'str'},
        'health_policy': {'key': 'healthPolicy', 'type': 'ClusterHealthPolicy'},
        'delta_health_policy': {'key': 'deltaHealthPolicy', 'type': 'ClusterUpgradeDeltaHealthPolicy'},
    }

    def __init__(self, **kwargs):
        super(ClusterUpgradePolicy, self).__init__(**kwargs)
        self.force_restart = kwargs.get('force_restart', None)
        self.upgrade_replica_set_check_timeout = kwargs.get('upgrade_replica_set_check_timeout', None)
        self.health_check_wait_duration = kwargs.get('health_check_wait_duration', None)
        self.health_check_stable_duration = kwargs.get('health_check_stable_duration', None)
        self.health_check_retry_timeout = kwargs.get('health_check_retry_timeout', None)
        self.upgrade_timeout = kwargs.get('upgrade_timeout', None)
        self.upgrade_domain_timeout = kwargs.get('upgrade_domain_timeout', None)
        self.health_policy = kwargs.get('health_policy', None)
        self.delta_health_policy = kwargs.get('delta_health_policy', None)


class EndpointRangeDescription(Model):
    """Port range details.

    All required parameters must be populated in order to send to Azure.

    :param start_port: Required. Starting port of a range of ports
    :type start_port: int
    :param end_port: Required. End port of a range of ports
    :type end_port: int
    """

    _validation = {
        'start_port': {'required': True},
        'end_port': {'required': True},
    }

    _attribute_map = {
        'start_port': {'key': 'startPort', 'type': 'int'},
        'end_port': {'key': 'endPort', 'type': 'int'},
    }

    def __init__(self, **kwargs):
        super(EndpointRangeDescription, self).__init__(**kwargs)
        self.start_port = kwargs.get('start_port', None)
        self.end_port = kwargs.get('end_port', None)


class ErrorModel(Model):
    """The structure of the error.

    :param error: The error details.
    :type error: ~azure.mgmt.servicefabric.models.ErrorModelError
    """

    _attribute_map = {
        'error': {'key': 'error', 'type': 'ErrorModelError'},
    }

    def __init__(self, **kwargs):
        super(ErrorModel, self).__init__(**kwargs)
        self.error = kwargs.get('error', None)


class ErrorModelException(HttpOperationError):
    """Server responsed with exception of type: 'ErrorModel'.

    :param deserialize: A deserializer
    :param response: Server response to be deserialized.
    """

    def __init__(self, deserialize, response, *args):

        super(ErrorModelException, self).__init__(deserialize, response, 'ErrorModel', *args)


class ErrorModelError(Model):
    """The error details.

    :param code: The error code.
    :type code: str
    :param message: The error message.
    :type message: str
    """

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ErrorModelError, self).__init__(**kwargs)
        self.code = kwargs.get('code', None)
        self.message = kwargs.get('message', None)


class LoadBalancePort(Model):
    """Load balance port.

    :param frontend_port: The public port number of the endpoint.
    :type frontend_port: int
    :param backend_port: The backend port number of the endpoint.
    :type backend_port: int
    :param protocol: The protocol of the endpoint. Possible values include:
     'tcp', 'udp', 'http'
    :type protocol: str or ~azure.mgmt.servicefabric.models.Protocol
    """

    _attribute_map = {
        'frontend_port': {'key': 'frontendPort', 'type': 'int'},
        'backend_port': {'key': 'backendPort', 'type': 'int'},
        'protocol': {'key': 'protocol', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(LoadBalancePort, self).__init__(**kwargs)
        self.frontend_port = kwargs.get('frontend_port', None)
        self.backend_port = kwargs.get('backend_port', None)
        self.protocol = kwargs.get('protocol', None)


class Resource(Model):
    """The resource model definition.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Azure resource identifier.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param location: Required. Azure resource location.
    :type location: str
    :param tags: Azure resource tags.
    :type tags: dict[str, str]
    :ivar etag: Azure resource etag.
    :vartype etag: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
        'etag': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'etag': {'key': 'etag', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(Resource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.location = kwargs.get('location', None)
        self.tags = kwargs.get('tags', None)
        self.etag = None


class ManagedCluster(Resource):
    """The manged cluster resource
    .

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Azure resource identifier.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param location: Required. Azure resource location.
    :type location: str
    :param tags: Azure resource tags.
    :type tags: dict[str, str]
    :ivar etag: Azure resource etag.
    :vartype etag: str
    :param dns_name: Required. The cluster dns name.
    :type dns_name: str
    :ivar fqdn: the cluster Fully qualified domain name.
    :vartype fqdn: str
    :ivar cluster_id: A service generated unique identifier for the cluster
     resource.
    :vartype cluster_id: str
    :ivar cluster_state: The current state of the cluster.
     - WaitingForNodes - Indicates that the cluster resource is created and the
     resource provider is waiting for Service Fabric VM extension to boot up
     and report to it.
     - Deploying - Indicates that the Service Fabric runtime is being installed
     on the VMs. Cluster resource will be in this state until the cluster boots
     up and system services are up.
     - BaselineUpgrade - Indicates that the cluster is upgrading to establishes
     the cluster version. This upgrade is automatically initiated when the
     cluster boots up for the first time.
     - UpdatingUserConfiguration - Indicates that the cluster is being upgraded
     with the user provided configuration.
     - UpdatingUserCertificate - Indicates that the cluster is being upgraded
     with the user provided certificate.
     - UpdatingInfrastructure - Indicates that the cluster is being upgraded
     with the latest Service Fabric runtime version. This happens only when the
     **upgradeMode** is set to 'Automatic'.
     - EnforcingClusterVersion - Indicates that cluster is on a different
     version than expected and the cluster is being upgraded to the expected
     version.
     - UpgradeServiceUnreachable - Indicates that the system service in the
     cluster is no longer polling the Resource Provider. Clusters in this state
     cannot be managed by the Resource Provider.
     - AutoScale - Indicates that the ReliabilityLevel of the cluster is being
     adjusted.
     - Ready - Indicates that the cluster is in a stable state.
     . Possible values include: 'WaitingForNodes', 'Deploying',
     'BaselineUpgrade', 'UpdatingUserConfiguration', 'UpdatingUserCertificate',
     'UpdatingInfrastructure', 'EnforcingClusterVersion',
     'UpgradeServiceUnreachable', 'AutoScale', 'Ready'
    :vartype cluster_state: str or ~azure.mgmt.servicefabric.models.enum
    :ivar cluster_certificate_thumbprint: The cluster certificate thumbprint
     used for admin client.
    :vartype cluster_certificate_thumbprint: str
    :ivar cluster_certificate_common_name: The cluster certificate common name
     used for admin client.
    :vartype cluster_certificate_common_name: str
    :param client_connection_port: The port used for client connections to the
     cluster. Default value: 19000 .
    :type client_connection_port: int
    :param http_gateway_connection_port: The port used for http connections to
     the cluster. Default value: 19080 .
    :type http_gateway_connection_port: int
    :param load_balance_ports: Load balance ports.
    :type load_balance_ports:
     list[~azure.mgmt.servicefabric.models.LoadBalancePort]
    :param nat_ports: Nat ports.
    :type nat_ports: list[~azure.mgmt.servicefabric.models.NatPort]
    :param vm_admin_user: Required. vm admin user name.
    :type vm_admin_user: str
    :param vm_password: vm admin user password.
    :type vm_password: str
    :param fabric_settings: The list of custom fabric settings to configure
     the cluster.
    :type fabric_settings:
     ~azure.mgmt.servicefabric.models.SettingsSectionDescription
    :ivar provisioning_state: The provisioning state of the managed cluster
     resource. Possible values include: 'Updating', 'Succeeded', 'Failed',
     'Canceled'
    :vartype provisioning_state: str or
     ~azure.mgmt.servicefabric.models.ProvisioningState
    :param cluster_code_version: The Service Fabric runtime version of the
     cluster. This property can only by set the user when **upgradeMode** is
     set to 'Manual'. To get list of available Service Fabric versions for new
     clusters use [ClusterVersion API](./ClusterVersion.md). To get the list of
     available version for existing clusters use **availableClusterVersions**.
    :type cluster_code_version: str
    :param cluster_upgrade_mode: The upgrade mode of the cluster when new
     Service Fabric runtime version is available.
     - Automatic - The cluster will be automatically upgraded to the latest
     Service Fabric runtime version as soon as it is available.
     - Manual - The cluster will not be automatically upgraded to the latest
     Service Fabric runtime version. The cluster is upgraded by setting the
     **clusterCodeVersion** property in the cluster resource.
     . Possible values include: 'Automatic', 'Manual'
    :type cluster_upgrade_mode: str or ~azure.mgmt.servicefabric.models.enum
    :param cluster_upgrade_description: Describes the policy used when
     upgrading the cluster.
    :type cluster_upgrade_description:
     ~azure.mgmt.servicefabric.models.ClusterUpgradePolicy
    :param reverse_proxy_endpoint_port: The endpoint used by reverse proxy.
    :type reverse_proxy_endpoint_port: int
    :ivar sku: The sku of the managed cluster
    :vartype sku: ~azure.mgmt.servicefabric.models.Sku
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
        'etag': {'readonly': True},
        'dns_name': {'required': True},
        'fqdn': {'readonly': True},
        'cluster_id': {'readonly': True},
        'cluster_state': {'readonly': True},
        'cluster_certificate_thumbprint': {'readonly': True},
        'cluster_certificate_common_name': {'readonly': True},
        'vm_admin_user': {'required': True},
        'provisioning_state': {'readonly': True},
        'sku': {'constant': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'etag': {'key': 'etag', 'type': 'str'},
        'dns_name': {'key': 'properties.dnsName', 'type': 'str'},
        'fqdn': {'key': 'properties.fqdn', 'type': 'str'},
        'cluster_id': {'key': 'properties.clusterId', 'type': 'str'},
        'cluster_state': {'key': 'properties.clusterState', 'type': 'str'},
        'cluster_certificate_thumbprint': {'key': 'properties.clusterCertificateThumbprint', 'type': 'str'},
        'cluster_certificate_common_name': {'key': 'properties.clusterCertificateCommonName', 'type': 'str'},
        'client_connection_port': {'key': 'properties.clientConnectionPort', 'type': 'int'},
        'http_gateway_connection_port': {'key': 'properties.httpGatewayConnectionPort', 'type': 'int'},
        'load_balance_ports': {'key': 'properties.loadBalancePorts', 'type': '[LoadBalancePort]'},
        'nat_ports': {'key': 'properties.natPorts', 'type': '[NatPort]'},
        'vm_admin_user': {'key': 'properties.vmAdminUser', 'type': 'str'},
        'vm_password': {'key': 'properties.vmPassword', 'type': 'str'},
        'fabric_settings': {'key': 'properties.fabricSettings', 'type': 'SettingsSectionDescription'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
        'cluster_code_version': {'key': 'properties.clusterCodeVersion', 'type': 'str'},
        'cluster_upgrade_mode': {'key': 'properties.clusterUpgradeMode', 'type': 'str'},
        'cluster_upgrade_description': {'key': 'properties.clusterUpgradeDescription', 'type': 'ClusterUpgradePolicy'},
        'reverse_proxy_endpoint_port': {'key': 'properties.reverseProxyEndpointPort', 'type': 'int'},
        'sku': {'key': 'sku', 'type': 'Sku'},
    }

    sku = Sku()

    def __init__(self, **kwargs):
        super(ManagedCluster, self).__init__(**kwargs)
        self.dns_name = kwargs.get('dns_name', None)
        self.fqdn = None
        self.cluster_id = None
        self.cluster_state = None
        self.cluster_certificate_thumbprint = None
        self.cluster_certificate_common_name = None
        self.client_connection_port = kwargs.get('client_connection_port', 19000)
        self.http_gateway_connection_port = kwargs.get('http_gateway_connection_port', 19080)
        self.load_balance_ports = kwargs.get('load_balance_ports', None)
        self.nat_ports = kwargs.get('nat_ports', None)
        self.vm_admin_user = kwargs.get('vm_admin_user', None)
        self.vm_password = kwargs.get('vm_password', None)
        self.fabric_settings = kwargs.get('fabric_settings', None)
        self.provisioning_state = None
        self.cluster_code_version = kwargs.get('cluster_code_version', None)
        self.cluster_upgrade_mode = kwargs.get('cluster_upgrade_mode', None)
        self.cluster_upgrade_description = kwargs.get('cluster_upgrade_description', None)
        self.reverse_proxy_endpoint_port = kwargs.get('reverse_proxy_endpoint_port', None)


class ManagedClusterUpdateParameters(Model):
    """Managed cluster update request.

    :param client_connection_port: The port used for client connections to the
     cluster.
    :type client_connection_port: int
    :param http_gateway_connection_port: The port used for http connections to
     the cluster.
    :type http_gateway_connection_port: int
    :param load_balance_ports: Load balance ports.
    :type load_balance_ports:
     list[~azure.mgmt.servicefabric.models.LoadBalancePort]
    :param nat_ports: Nat ports.
    :type nat_ports: list[~azure.mgmt.servicefabric.models.NatPort]
    :param fabric_settings: The list of custom fabric settings to configure
     the cluster.
    :type fabric_settings:
     ~azure.mgmt.servicefabric.models.SettingsSectionDescription
    :param cluster_code_version: The Service Fabric runtime version of the
     cluster. This property can only by set the user when **upgradeMode** is
     set to 'Manual'. To get list of available Service Fabric versions for new
     clusters use [ClusterVersion API](./ClusterVersion.md). To get the list of
     available version for existing clusters use **availableClusterVersions**.
    :type cluster_code_version: str
    :param cluster_upgrade_mode: The upgrade mode of the cluster when new
     Service Fabric runtime version is available.
     - Automatic - The cluster will be automatically upgraded to the latest
     Service Fabric runtime version as soon as it is available.
     - Manual - The cluster will not be automatically upgraded to the latest
     Service Fabric runtime version. The cluster is upgraded by setting the
     **clusterCodeVersion** property in the cluster resource.
     . Possible values include: 'Automatic', 'Manual'
    :type cluster_upgrade_mode: str or ~azure.mgmt.servicefabric.models.enum
    :param cluster_upgrade_description: Describes the policy used when
     upgrading the cluster.
    :type cluster_upgrade_description:
     ~azure.mgmt.servicefabric.models.ClusterUpgradePolicy
    :param reverse_proxy_endpoint_port: The endpoint used by reverse proxy.
    :type reverse_proxy_endpoint_port: int
    :param tags: Managed cluster update parameters
    :type tags: dict[str, str]
    """

    _attribute_map = {
        'client_connection_port': {'key': 'properties.clientConnectionPort', 'type': 'int'},
        'http_gateway_connection_port': {'key': 'properties.httpGatewayConnectionPort', 'type': 'int'},
        'load_balance_ports': {'key': 'properties.loadBalancePorts', 'type': '[LoadBalancePort]'},
        'nat_ports': {'key': 'properties.natPorts', 'type': '[NatPort]'},
        'fabric_settings': {'key': 'properties.fabricSettings', 'type': 'SettingsSectionDescription'},
        'cluster_code_version': {'key': 'properties.clusterCodeVersion', 'type': 'str'},
        'cluster_upgrade_mode': {'key': 'properties.clusterUpgradeMode', 'type': 'str'},
        'cluster_upgrade_description': {'key': 'properties.clusterUpgradeDescription', 'type': 'ClusterUpgradePolicy'},
        'reverse_proxy_endpoint_port': {'key': 'properties.reverseProxyEndpointPort', 'type': 'int'},
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(self, **kwargs):
        super(ManagedClusterUpdateParameters, self).__init__(**kwargs)
        self.client_connection_port = kwargs.get('client_connection_port', None)
        self.http_gateway_connection_port = kwargs.get('http_gateway_connection_port', None)
        self.load_balance_ports = kwargs.get('load_balance_ports', None)
        self.nat_ports = kwargs.get('nat_ports', None)
        self.fabric_settings = kwargs.get('fabric_settings', None)
        self.cluster_code_version = kwargs.get('cluster_code_version', None)
        self.cluster_upgrade_mode = kwargs.get('cluster_upgrade_mode', None)
        self.cluster_upgrade_description = kwargs.get('cluster_upgrade_description', None)
        self.reverse_proxy_endpoint_port = kwargs.get('reverse_proxy_endpoint_port', None)
        self.tags = kwargs.get('tags', None)


class NatPort(Model):
    """Nat port.

    :param frontend_start_port: The public port number of the endpoint.
    :type frontend_start_port: int
    :param backend_port: The backend port number of the endpoint.
    :type backend_port: int
    """

    _attribute_map = {
        'frontend_start_port': {'key': 'frontendStartPort', 'type': 'int'},
        'backend_port': {'key': 'backendPort', 'type': 'int'},
    }

    def __init__(self, **kwargs):
        super(NatPort, self).__init__(**kwargs)
        self.frontend_start_port = kwargs.get('frontend_start_port', None)
        self.backend_port = kwargs.get('backend_port', None)


class ProxyResource(Model):
    """The resource model definition for proxy-only resource.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Azure resource identifier.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param tags: Azure resource tags.
    :type tags: dict[str, str]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(self, **kwargs):
        super(ProxyResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.tags = kwargs.get('tags', None)


class NodeType(ProxyResource):
    """Describes a node type in the cluster, each node type represents sub set of
    nodes in the cluster.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Azure resource identifier.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param tags: Azure resource tags.
    :type tags: dict[str, str]
    :param is_primary: Required. The node type on which system services will
     run. Only one node type should be marked as primary. Primary node type
     cannot be deleted or changed for existing clusters.
    :type is_primary: bool
    :param vm_instance_count: Required. The number of nodes in the node type.
     This count should match the capacity property in the corresponding
     VirtualMachineScaleSet resource.
    :type vm_instance_count: int
    :param disk_size_in_gb: Required. Disk size for each vm in the node type
     in GBs.
    :type disk_size_in_gb: int
    :param placement_properties: The placement tags applied to nodes in the
     node type, which can be used to indicate where certain services (workload)
     should run.
    :type placement_properties: dict[str, str]
    :param capacities: The capacity tags applied to the nodes in the node
     type, the cluster resource manager uses these tags to understand how much
     resource a node has.
    :type capacities: dict[str, str]
    :param application_ports: The range of ports from which cluster assigned
     port to Service Fabric applications.
    :type application_ports:
     ~azure.mgmt.servicefabric.models.EndpointRangeDescription
    :param ephemeral_ports: The range of ephemeral ports that nodes in this
     node type should be configured with.
    :type ephemeral_ports:
     ~azure.mgmt.servicefabric.models.EndpointRangeDescription
    :param vm_size: The size of virtual machines in the pool. All virtual
     machines in a pool are the same size. For example, Standard_D3.
    :type vm_size: str
    :param vm_image_publisher: The publisher of the Azure Virtual Machines
     Marketplace image. For example, Canonical or MicrosoftWindowsServer.
    :type vm_image_publisher: str
    :param vm_image_offer: The offer type of the Azure Virtual Machines
     Marketplace image. For example, UbuntuServer or WindowsServer.
    :type vm_image_offer: str
    :param vm_image_sku: The SKU of the Azure Virtual Machines Marketplace
     image. For example, 14.04.0-LTS or 2012-R2-Datacenter.
    :type vm_image_sku: str
    :param vm_image_version: The version of the Azure Virtual Machines
     Marketplace image. A value of 'latest' can be specified to select the
     latest version of an image. If omitted, the default is 'latest'.
    :type vm_image_version: str
    :param vm_secrets: virtual machine secretes. The secrets to install in the
     virtual machines.
    :type vm_secrets: list[~azure.mgmt.servicefabric.models.VaultSecretGroup]
    :param vm_extensions: virtual machine extensions. Set of extensions that
     should be installed onto the virtual machines.
    :type vm_extensions: list[~azure.mgmt.servicefabric.models.VMSSExtension]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'is_primary': {'required': True},
        'vm_instance_count': {'required': True, 'maximum': 2147483647, 'minimum': 1},
        'disk_size_in_gb': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'is_primary': {'key': 'properties.isPrimary', 'type': 'bool'},
        'vm_instance_count': {'key': 'properties.vmInstanceCount', 'type': 'int'},
        'disk_size_in_gb': {'key': 'properties.diskSizeInGB', 'type': 'int'},
        'placement_properties': {'key': 'properties.placementProperties', 'type': '{str}'},
        'capacities': {'key': 'properties.capacities', 'type': '{str}'},
        'application_ports': {'key': 'properties.applicationPorts', 'type': 'EndpointRangeDescription'},
        'ephemeral_ports': {'key': 'properties.ephemeralPorts', 'type': 'EndpointRangeDescription'},
        'vm_size': {'key': 'properties.vmSize', 'type': 'str'},
        'vm_image_publisher': {'key': 'properties.vmImagePublisher', 'type': 'str'},
        'vm_image_offer': {'key': 'properties.vmImageOffer', 'type': 'str'},
        'vm_image_sku': {'key': 'properties.vmImageSku', 'type': 'str'},
        'vm_image_version': {'key': 'properties.vmImageVersion', 'type': 'str'},
        'vm_secrets': {'key': 'properties.vmSecrets', 'type': '[VaultSecretGroup]'},
        'vm_extensions': {'key': 'properties.vmExtensions', 'type': '[VMSSExtension]'},
    }

    def __init__(self, **kwargs):
        super(NodeType, self).__init__(**kwargs)
        self.is_primary = kwargs.get('is_primary', None)
        self.vm_instance_count = kwargs.get('vm_instance_count', None)
        self.disk_size_in_gb = kwargs.get('disk_size_in_gb', None)
        self.placement_properties = kwargs.get('placement_properties', None)
        self.capacities = kwargs.get('capacities', None)
        self.application_ports = kwargs.get('application_ports', None)
        self.ephemeral_ports = kwargs.get('ephemeral_ports', None)
        self.vm_size = kwargs.get('vm_size', None)
        self.vm_image_publisher = kwargs.get('vm_image_publisher', None)
        self.vm_image_offer = kwargs.get('vm_image_offer', None)
        self.vm_image_sku = kwargs.get('vm_image_sku', None)
        self.vm_image_version = kwargs.get('vm_image_version', None)
        self.vm_secrets = kwargs.get('vm_secrets', None)
        self.vm_extensions = kwargs.get('vm_extensions', None)


class NodeTypeUpdateParameters(Model):
    """Node type update request.

    :param vm_instance_count: The number of nodes in the node type. This count
     should match the capacity property in the corresponding
     VirtualMachineScaleSet resource.
    :type vm_instance_count: int
    :param placement_properties: The placement tags applied to nodes in the
     node type, which can be used to indicate where certain services (workload)
     should run.
    :type placement_properties: dict[str, str]
    :param capacities: The capacity tags applied to the nodes in the node
     type, the cluster resource manager uses these tags to understand how much
     resource a node has.
    :type capacities: dict[str, str]
    :param application_ports: The range of ports from which cluster assigned
     port to Service Fabric applications.
    :type application_ports:
     ~azure.mgmt.servicefabric.models.EndpointRangeDescription
    :param ephemeral_ports: The range of ephemeral ports that nodes in this
     node type should be configured with.
    :type ephemeral_ports:
     ~azure.mgmt.servicefabric.models.EndpointRangeDescription
    :param vm_secrets: virtual machine secretes. The secrets to install in the
     virtual machines.
    :type vm_secrets: list[~azure.mgmt.servicefabric.models.VaultSecretGroup]
    :param vm_extensions: virtual machine extensions. Set of extensions that
     should be installed onto the virtual machines.
    :type vm_extensions: list[~azure.mgmt.servicefabric.models.VMSSExtension]
    :param tags: Node type update parameters
    :type tags: dict[str, str]
    """

    _validation = {
        'vm_instance_count': {'maximum': 2147483647, 'minimum': 1},
    }

    _attribute_map = {
        'vm_instance_count': {'key': 'properties.vmInstanceCount', 'type': 'int'},
        'placement_properties': {'key': 'properties.placementProperties', 'type': '{str}'},
        'capacities': {'key': 'properties.capacities', 'type': '{str}'},
        'application_ports': {'key': 'properties.applicationPorts', 'type': 'EndpointRangeDescription'},
        'ephemeral_ports': {'key': 'properties.ephemeralPorts', 'type': 'EndpointRangeDescription'},
        'vm_secrets': {'key': 'properties.vmSecrets', 'type': '[VaultSecretGroup]'},
        'vm_extensions': {'key': 'properties.vmExtensions', 'type': '[VMSSExtension]'},
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(self, **kwargs):
        super(NodeTypeUpdateParameters, self).__init__(**kwargs)
        self.vm_instance_count = kwargs.get('vm_instance_count', None)
        self.placement_properties = kwargs.get('placement_properties', None)
        self.capacities = kwargs.get('capacities', None)
        self.application_ports = kwargs.get('application_ports', None)
        self.ephemeral_ports = kwargs.get('ephemeral_ports', None)
        self.vm_secrets = kwargs.get('vm_secrets', None)
        self.vm_extensions = kwargs.get('vm_extensions', None)
        self.tags = kwargs.get('tags', None)


class OperationResult(Model):
    """Available operation list result.

    :param name: The name of the operation.
    :type name: str
    :param display: The object that represents the operation.
    :type display: ~azure.mgmt.servicefabric.models.AvailableOperationDisplay
    :param origin: Origin result
    :type origin: str
    :param next_link: The URL to use for getting the next set of results.
    :type next_link: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'display': {'key': 'display', 'type': 'AvailableOperationDisplay'},
        'origin': {'key': 'origin', 'type': 'str'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(OperationResult, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.display = kwargs.get('display', None)
        self.origin = kwargs.get('origin', None)
        self.next_link = kwargs.get('next_link', None)


class ServiceTypeDeltaHealthPolicy(Model):
    """Represents the delta health policy used to evaluate the health of services
    belonging to a service type when upgrading the cluster.
    .

    :param max_percent_delta_unhealthy_services: The maximum allowed
     percentage of services health degradation allowed during cluster upgrades.
     The delta is measured between the state of the services at the beginning
     of upgrade and the state of the services at the time of the health
     evaluation.
     The check is performed after every upgrade domain upgrade completion to
     make sure the global state of the cluster is within tolerated limits.
     . Default value: 0 .
    :type max_percent_delta_unhealthy_services: int
    """

    _validation = {
        'max_percent_delta_unhealthy_services': {'maximum': 100, 'minimum': 0},
    }

    _attribute_map = {
        'max_percent_delta_unhealthy_services': {'key': 'maxPercentDeltaUnhealthyServices', 'type': 'int'},
    }

    def __init__(self, **kwargs):
        super(ServiceTypeDeltaHealthPolicy, self).__init__(**kwargs)
        self.max_percent_delta_unhealthy_services = kwargs.get('max_percent_delta_unhealthy_services', 0)


class ServiceTypeHealthPolicy(Model):
    """Represents the health policy used to evaluate the health of services
    belonging to a service type.
    .

    :param max_percent_unhealthy_services: The maximum percentage of services
     allowed to be unhealthy before your application is considered in error.
     . Default value: 0 .
    :type max_percent_unhealthy_services: int
    """

    _validation = {
        'max_percent_unhealthy_services': {'maximum': 100, 'minimum': 0},
    }

    _attribute_map = {
        'max_percent_unhealthy_services': {'key': 'maxPercentUnhealthyServices', 'type': 'int'},
    }

    def __init__(self, **kwargs):
        super(ServiceTypeHealthPolicy, self).__init__(**kwargs)
        self.max_percent_unhealthy_services = kwargs.get('max_percent_unhealthy_services', 0)


class SettingsParameterDescription(Model):
    """Describes a parameter in fabric settings of the cluster.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The parameter name of fabric setting.
    :type name: str
    :param value: Required. The parameter value of fabric setting.
    :type value: str
    """

    _validation = {
        'name': {'required': True},
        'value': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(SettingsParameterDescription, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.value = kwargs.get('value', None)


class SettingsSectionDescription(Model):
    """Describes a section in the fabric settings of the cluster.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The section name of the fabric settings.
    :type name: str
    :param parameters: Required. The collection of parameters in the section.
    :type parameters:
     list[~azure.mgmt.servicefabric.models.SettingsParameterDescription]
    """

    _validation = {
        'name': {'required': True},
        'parameters': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'parameters': {'key': 'parameters', 'type': '[SettingsParameterDescription]'},
    }

    def __init__(self, **kwargs):
        super(SettingsSectionDescription, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.parameters = kwargs.get('parameters', None)


class Sku(Model):
    """Sku definition.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. Sku Name.
     - Basic. Default value: "Basic" .
    :vartype name: str
    """

    _validation = {
        'name': {'required': True, 'constant': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
    }

    name = "Basic"


class SubResource(Model):
    """Azure resource identifier.

    :param id: Azure resource identifier.
    :type id: str
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(SubResource, self).__init__(**kwargs)
        self.id = kwargs.get('id', None)


class VaultCertificate(Model):
    """Describes a single certificate reference in a Key Vault, and where the
    certificate should reside on the VM.

    All required parameters must be populated in order to send to Azure.

    :param certificate_url: Required. This is the URL of a certificate that
     has been uploaded to Key Vault as a secret. For adding a secret to the Key
     Vault, see [Add a key or secret to the key
     vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add).
     In this case, your certificate needs to be It is the Base64 encoding of
     the following JSON Object which is encoded in UTF-8: <br><br> {<br>
     "data":"<Base64-encoded-certificate>",<br>  "dataType":"pfx",<br>
     "password":"<pfx-file-password>"<br>}
    :type certificate_url: str
    :param certificate_store: Required. For Windows VMs, specifies the
     certificate store on the Virtual Machine to which the certificate should
     be added. The specified certificate store is implicitly in the
     LocalMachine account. <br><br>For Linux VMs, the certificate file is
     placed under the /var/lib/waagent directory, with the file name
     <UppercaseThumbprint>.crt for the X509 certificate file and
     <UppercaseThumbprint>.prv for private key. Both of these files are .pem
     formatted.
    :type certificate_store: str
    """

    _validation = {
        'certificate_url': {'required': True},
        'certificate_store': {'required': True},
    }

    _attribute_map = {
        'certificate_url': {'key': 'certificateUrl', 'type': 'str'},
        'certificate_store': {'key': 'certificateStore', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(VaultCertificate, self).__init__(**kwargs)
        self.certificate_url = kwargs.get('certificate_url', None)
        self.certificate_store = kwargs.get('certificate_store', None)


class VaultSecretGroup(Model):
    """Specifies set of certificates that should be installed onto the virtual
    machines.

    All required parameters must be populated in order to send to Azure.

    :param source_vault: Required. The relative URL of the Key Vault
     containing all of the certificates in VaultCertificates.
    :type source_vault: ~azure.mgmt.servicefabric.models.SubResource
    :param vault_certificates: Required. The list of key vault references in
     SourceVault which contain certificates.
    :type vault_certificates:
     list[~azure.mgmt.servicefabric.models.VaultCertificate]
    """

    _validation = {
        'source_vault': {'required': True},
        'vault_certificates': {'required': True},
    }

    _attribute_map = {
        'source_vault': {'key': 'sourceVault', 'type': 'SubResource'},
        'vault_certificates': {'key': 'vaultCertificates', 'type': '[VaultCertificate]'},
    }

    def __init__(self, **kwargs):
        super(VaultSecretGroup, self).__init__(**kwargs)
        self.source_vault = kwargs.get('source_vault', None)
        self.vault_certificates = kwargs.get('vault_certificates', None)


class VMSSExtension(Model):
    """Specifies set of extensions that should be installed onto the virtual
    machines.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The name of the extension.
    :type name: str
    :param publisher: Required. The name of the extension handler publisher.
    :type publisher: str
    :param type: Required. Specifies the type of the extension; an example is
     "CustomScriptExtension".
    :type type: str
    :param type_handler_version: Required. Specifies the version of the script
     handler.
    :type type_handler_version: str
    :param auto_upgrade_minor_version: Indicates whether the extension should
     use a newer minor version if one is available at deployment time. Once
     deployed, however, the extension will not upgrade minor versions unless
     redeployed, even with this property set to true.
    :type auto_upgrade_minor_version: bool
    :param enable_automatic_upgrade: Indicates if the extension will upgrade
     automatically.
    :type enable_automatic_upgrade: bool
    :param settings: Json formatted public settings for the extension.
    :type settings: object
    :param protected_settings: The extension can contain either
     protectedSettings or protectedSettingsFromKeyVault or no protected
     settings at all.
    :type protected_settings: object
    :ivar provisioning_state: The provisioning state, which only appears in
     the response.
    :vartype provisioning_state: str
    """

    _validation = {
        'name': {'required': True},
        'publisher': {'required': True},
        'type': {'required': True},
        'type_handler_version': {'required': True},
        'provisioning_state': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'publisher': {'key': 'properties.publisher', 'type': 'str'},
        'type': {'key': 'properties.type', 'type': 'str'},
        'type_handler_version': {'key': 'properties.typeHandlerVersion', 'type': 'str'},
        'auto_upgrade_minor_version': {'key': 'properties.autoUpgradeMinorVersion', 'type': 'bool'},
        'enable_automatic_upgrade': {'key': 'properties.enableAutomaticUpgrade', 'type': 'bool'},
        'settings': {'key': 'properties.settings', 'type': 'object'},
        'protected_settings': {'key': 'properties.protectedSettings', 'type': 'object'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(VMSSExtension, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.publisher = kwargs.get('publisher', None)
        self.type = kwargs.get('type', None)
        self.type_handler_version = kwargs.get('type_handler_version', None)
        self.auto_upgrade_minor_version = kwargs.get('auto_upgrade_minor_version', None)
        self.enable_automatic_upgrade = kwargs.get('enable_automatic_upgrade', None)
        self.settings = kwargs.get('settings', None)
        self.protected_settings = kwargs.get('protected_settings', None)
        self.provisioning_state = None
